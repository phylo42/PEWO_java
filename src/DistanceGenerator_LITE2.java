
import dtx.Dtx;
import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import jplace.JplacerLoader;
import jplace.JplacerLoader.Placement;
import tree.PhyloTree;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author ben
 */
public class DistanceGenerator_LITE2 {
    
    //workDir
    String HOME = System.getenv("HOME");
    File workDir=new File(HOME);

    //which component to score ?
    boolean doEPA=true;
    boolean doPPL=true;
    boolean doRAP=true;
    boolean doEPANG=true;
    boolean doAPPLES=true;
    boolean doAPPSPAM=true;
    
    public static void main(String[] args) {
        
        //System.setProperty("debug.verbose","1");


        ObjectInputStream ois=null;
        
        try {
            
            System.out.println("ARGS: workDir doEPA[1/0] doEPANG[0/1] doPPL[1/0] doRAP[0/1] doAPPLES[0,1] doAPPSPAM[0,1]");

            //launch
            DistanceGenerator_LITE2 dg=new DistanceGenerator_LITE2();

            System.out.println(System.getProperty("java.class.path"));

            if(args.length>0) {
                dg.workDir=new File(args[0]);
                System.out.println("workDir: "+dg.workDir);
                if (Integer.parseInt(args[1])<1) { dg.doEPA=false; }
                if (Integer.parseInt(args[2])<1) { dg.doEPANG=false; }
                if (Integer.parseInt(args[3])<1) { dg.doPPL=false; }
                if (Integer.parseInt(args[4])<1) { dg.doRAP=false; }
                if (Integer.parseInt(args[5])<1) { dg.doAPPLES=false; }
		        if (Integer.parseInt(args[6])<1) { dg.doAPPSPAM=false; }
            }

            //LOAD BINARY INFORMATION
            ////////////////////////////////////////////////////

            //expected placement
            File expPLaceFile=new File(dg.workDir+File.separator+"expected_placements.bin");
            //Dtx
            File DtxFile=new File(dg.workDir+File.separator+"Dtx.csv");

            //load the expected placement
            System.out.println("Loading "+expPLaceFile.getAbsolutePath());
            ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(expPLaceFile),4096));
            System.out.println("Loading NxIndex");
            HashMap<Integer,Integer> NxIndex = (HashMap<Integer,Integer>)ois.readObject();
            System.out.println("Loading pruningIndex");
            HashMap<Integer,Integer> pruningIndex = (HashMap<Integer,Integer>)ois.readObject();
            System.out.println("Loading expected placements");
            ArrayList<ArrayList<Integer>> expectedPlacements = (ArrayList<ArrayList<Integer>>)ois.readObject();
            System.out.println("Loading trees");
            ArrayList<PhyloTree> experimentTrees = (ArrayList<PhyloTree>)ois.readObject();
            System.out.println("Loading trees trifurcations");
            ArrayList<ArrayList<PhyloTree>> experimentTreesTrifurcations = (ArrayList<ArrayList<PhyloTree>>)ois.readObject();

            System.out.println("################################################");
            System.out.println("NxIndex="+NxIndex);
            System.out.println("pruningIndex="+NxIndex);
            System.out.println("expectedPlacements="+expectedPlacements);
            System.out.println("prunedTrees="+experimentTrees.size());
            for (int i = 0; i < experimentTrees.size(); i++) {
                PhyloTree get = experimentTrees.get(i);
                System.out.println(i+"th tree size test:"+get.getNodeCount());
            }
            System.out.println("################################################");
            //load Dtx
            System.out.println("Loading Dtx matrix...");
            Dtx Dtx=new Dtx(DtxFile);
            //System.out.println(Dtx);

            
            //LOAD ALL EXPERIMENTS FOUND IN WORK DIR
            ///////////////////////////////////////////////////

            //load list of all jplaces generated by the workflow
            List<Path> allJplaceFiles = new ArrayList<>();
            if (dg.doEPA) {
                System.out.println("Scanning for EPA jplace results...");
                File dir=new File(dg.workDir+File.separator+"EPA");
                List<Path> jplaceFiles = Files.find(dir.toPath(), 999, (p,b)-> b.isRegularFile() && p.getFileName().toString().endsWith(".jplace")).collect(Collectors.toList());
                System.out.println("# jplace found: "+jplaceFiles.size());
                allJplaceFiles.addAll(jplaceFiles);
            } 
            if (dg.doEPANG) {
                System.out.println("Scanning for EPANG jplace results...");
                File dir=new File(dg.workDir+File.separator+"EPANG");
                List<Path> jplaceFiles = Files.find(dir.toPath(), 999, (p,b)-> b.isRegularFile() && p.getFileName().toString().endsWith(".jplace")).collect(Collectors.toList());
                System.out.println("# jplace found: "+jplaceFiles.size());
                allJplaceFiles.addAll(jplaceFiles);
            }
            if (dg.doPPL) {
                System.out.println("Scanning for PPLACER jplace results...");
                File dir=new File(dg.workDir+File.separator+"PPLACER");
                List<Path> jplaceFiles = Files.find(dir.toPath(), 999, (p,b)-> b.isRegularFile() && p.getFileName().toString().endsWith(".jplace")).collect(Collectors.toList());
                System.out.println("# jplace found: "+jplaceFiles.size());
                allJplaceFiles.addAll(jplaceFiles);
            }
            if (dg.doRAP) {
                System.out.println("Scanning for RAPPAS jplace results...");
                File dir=new File(dg.workDir+File.separator+"RAPPAS");
                List<Path> jplaceFiles = Files.find(dir.toPath(), 999, (p,b)-> b.isRegularFile() && p.getFileName().toString().endsWith(".jplace")).collect(Collectors.toList());
                System.out.println("# jplace found: "+jplaceFiles.size());
                allJplaceFiles.addAll(jplaceFiles);
            }
            if (dg.doAPPLES) {
                System.out.println("Scanning for APPLES jplace results...");
                File dir=new File(dg.workDir+File.separator+"APPLES");
                List<Path> jplaceFiles = Files.find(dir.toPath(), 999, (p,b)-> b.isRegularFile() && p.getFileName().toString().endsWith(".jplace")).collect(Collectors.toList());
                System.out.println("# jplace found: "+jplaceFiles.size());
                allJplaceFiles.addAll(jplaceFiles);
            } 
	        if (dg.doAPPSPAM) {
 		        System.out.println("Scanning for APPSPAM jplace results...");
		        File dir=new File(dg.workDir+File.separator+"APPSPAM");
		        List<Path> jplaceFiles = Files.find(dir.toPath(), 999, (p,b)-> b.isRegularFile() && p.getFileName().toString().endsWith(".jplace")).collect(Collectors.toList());
		        System.out.println("# jplace found: "+jplaceFiles.size());
		        allJplaceFiles.addAll(jplaceFiles);
	        }

            //////////////////////////////////////////////////////////
            // DEFINED LIST OF PARAMETERS TESTED IN WORKFLOW
            // BY REGISTERING PARAMETER/COLUMN INFORMATION

            LinkedHashMap<String,Integer> paramSet=new LinkedHashMap<>(32);
            int columnCounter=-1;

            //information common to all software
            //paramSet.put("file",++columnCounter);
            paramSet.put("software",++columnCounter);
            paramSet.put("pruning",++columnCounter);
            //paramSet.put("rname",++columnCounter);
            paramSet.put("rstart",++columnCounter);
            paramSet.put("rend",++columnCounter);
            paramSet.put("nd",++columnCounter);
            paramSet.put("e_nd",++columnCounter);

            //pattern 
            //([0-9]+)_r([0-9]+)_([a-z]+)([0-9A-Z]+)_.*_([a-z]+)\.jplace
            //define from jplace filenames which parameters were tested
            final Pattern pat= Pattern.compile("([a-z]+)([0-9A-Z\\.]+)");
            for (Path p:allJplaceFiles) {
                String filename = p.toFile().getName();
                String[] infos = filename.split("_");
                //1st element is pruning id, last element is "software.jplace"
                for (int i = 1; i < infos.length - 1; i++) {
                    Matcher m = pat.matcher(infos[i]);
                    if (m.matches()) {
                        String param=m.group(1);
                        if (!paramSet.containsKey(param)) {
                            paramSet.put(m.group(1), ++columnCounter);
                        }
                    }
                }
            }
            //System.out.println("Param set: "+paramSet);
            
            
            //prepare a nice CSV file in which all data will be saved
            Path csvResult=Paths.get(dg.workDir.getAbsolutePath(),"results.csv");
            BufferedWriter bw= Files.newBufferedWriter(csvResult);
            //header
            int col=0;
            for (Iterator<String> it=paramSet.keySet().iterator();it.hasNext();) {
                String p=it.next();
                if (col>0) {
                    bw.append(";");
                }
                bw.append(p);
                col++;
            }
            bw.append("\n");


            
            // FOR EACH JPLACE, COMPUTE NODE DISTANCE
            /////////////////////////////////////////////////////


            //for each jplace file, calculate node dist
            for (int i = 0; i < allJplaceFiles.size(); i++) {
                Path currentJPlaceFile = allJplaceFiles.get(i);
                String jplaceLabel=currentJPlaceFile.getFileName().toString().split("\\.jplace$")[0];
                String[]elts=jplaceLabel.split("_");

                //information related to this placement
                int pruning=Integer.valueOf(elts[0]);
                String software=elts[elts.length-1];

                System.out.println("--------------------------------------");
                System.out.println("Parsing "+currentJPlaceFile.getFileName().toString());
                //System.out.println("software:"+software+" pruning:"+pruning);

                String[] infos=jplaceLabel.split("_");
                //System.out.println(Arrays.toString(infos));
                TreeMap<Integer,String> paramsValues=new TreeMap<>();
                for (int idx = 1; idx < infos.length-1; idx++) {
                    Matcher m=pat.matcher(infos[idx]);
                    if (m.matches()) {
                        String param=m.group(1);
                        if (paramSet.containsKey(param)) {
                            String val=m.group(2);
                            paramsValues.put(paramSet.get(param),val);
                        }
                    } else {
                        System.out.println("Error in jplace filename parameters coding, do not matches expected patter.");
                        System.exit(1);
                    }
                }
                //paramsValues.put(paramSet.get("file"),jplaceLabel);
                paramsValues.put(paramSet.get("pruning"),Integer.toString(pruning));
                paramsValues.put(paramSet.get("software"),software);

                //System.out.println(paramsValues);

                //load tree and expectedPlacements related to this pruning
                PhyloTree experimentTree=experimentTrees.get(pruning);
                experimentTree.initIndexes();
                ArrayList<Integer> experimentPlacements=expectedPlacements.get(pruning);

                //load jplace content
                JplacerLoader jpl=null;
                if (!software.equals("epang")) {
                    jpl=new JplacerLoader(currentJPlaceFile.toFile(), false);
                } else {
                    //was false with older versions of epang, but now seems to conserve root correctly,
                    //code kept if need to reverse
                    jpl=new JplacerLoader(currentJPlaceFile.toFile(), false);
                }


                if (jpl.getTree().getNodeCount()!=experimentTree.getNodeCount()) {
                    jpl.getTree().displayTree();
                    experimentTree.displayTree();
                    System.out.println("Something is wrong between the JPlace and expected_placements.bin trees.");
                    System.out.println("They do not include the same trees for the same Nx experiment.");
                    //return;
                    System.exit(1);
                }

                //version of EPA-ng prior to 0.3.4 unroots the input tree
                //this needs to be corrected, posterior versions, not need to correct

                if (jpl.getTree().getNodeCount()!=experimentTree.getNodeCount()) {
                    System.out.println("Something is wrong between the JPlace and expected_placements.bin trees.");
                    System.out.println("They do not include the same trees for the same Nx experiment.");
                    System.exit(1);
                }

                //map EPA jplace to experimentTree
                HashMap<Integer, Integer> mapNodes = jpl.getTree().mapNodes(experimentTree);
                //retrieve best placements
                HashMap<String, ArrayList<Placement>> EPABestPlacements = jpl.getPlacements();

                //iterate on placements
                for (Iterator<String> iterator = EPABestPlacements.keySet().iterator(); iterator.hasNext();) {
                    String name = iterator.next();

                    int topND=-1;
                    double topLwr=-1;
                    ArrayList<Integer> nds=new ArrayList<>();
                    ArrayList<Double> lwrs=new ArrayList<>();
                    double lwrSum=0.0;
                    //iterate on placement branches once to compute (expected_ND)*LWR sum
                    for (int pla=0;pla<EPABestPlacements.get(name).size();pla++) {
                        //get best placement as the nodeId of the phylotree generated
                        //during jplace parsing
                        Integer jplacePhyloTreeNodeId = EPABestPlacements.get(name).get(pla).getNodeId();
                        double lwr=EPABestPlacements.get(name).get(pla).getWeightRatio();
                        if (pla==0) {topLwr=lwr;}
                        //get its equivalent nodeId in the phylotree loaded from the
                        //expected_placements.bin
                        int experimentTreeNodeId = mapNodes.get(jplacePhyloTreeNodeId);
                        //calculate the distance between these 2 nodeIds
                        //i.e. use the DTx and D'Tx matrices
                        int nodeDistance = Dtx.getNodeDistance(pruningIndex.get(pruning), experimentTreeNodeId)+1;
                        if (pla==0) {topND=nodeDistance;}
                        lwrSum +=lwr;
                    }

                    //iterate again to compute eND
                    double expectedNodeDistance=0.0;
                    for (int pla=0;pla<EPABestPlacements.get(name).size();pla++) {
                        //get best placement as the nodeId of the phylotree generated
                        //during jplace parsing
                        Integer jplacePhyloTreeNodeId = EPABestPlacements.get(name).get(pla).getNodeId();
                        double lwr=EPABestPlacements.get(name).get(pla).getWeightRatio();
                        if (pla==0) {topLwr=lwr;}
                        //get its equivalent nodeId in the phylotree loaded from the
                        //expected_placements.bin
                        int experimentTreeNodeId = mapNodes.get(jplacePhyloTreeNodeId);
                        //calculate the distance between these 2 nodeIds
                        //i.e. use the DTx and D'Tx matrices
                        int nodeDistance = Dtx.getNodeDistance(pruningIndex.get(pruning), experimentTreeNodeId)+1;
                        if (pla==0) {topND=nodeDistance;}
                        expectedNodeDistance+=nodeDistance*lwr/lwrSum;
                    }

                    //got coordinates of placed read
                    String[] readInfos = name.split("_");
                    long readStart = 0;
                    long readEnd = 0;
                    try {
                        readStart = Long.decode(readInfos[readInfos.length - 2]);
                    } catch (NumberFormatException ex) {
                        ex.printStackTrace();
                    }
                    try {
                        readEnd = Long.decode(readInfos[readInfos.length - 1]);
                    } catch (NumberFormatException ex) {
                        ex.printStackTrace();
                    }

                    //add information only in specific columns
                    //paramsValues.put(paramSet.get("rname"),name);
                    paramsValues.put(paramSet.get("rstart"),Long.toString(readStart));
                    paramsValues.put(paramSet.get("rend"),Long.toString(readEnd));
                    paramsValues.put(paramSet.get("nd"),Integer.toString(topND));
                    paramsValues.put(paramSet.get("e_nd"),Double.toString(expectedNodeDistance));

                    //System.out.println(paramsValues);

                    //now build output string
                    for (int column=0;column<paramSet.keySet().size();column++) {
                        if (column>0) {
                            bw.append(";");
                        }
                        if (paramsValues.containsKey(column)) {
                            bw.append(paramsValues.get(column));
                        }
                    }
                    bw.append("\n");
                }




            }

            bw.close();

            System.exit(0);

        } catch (FileNotFoundException ex) {
            Logger.getLogger(DistanceGenerator_LITE.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException | ClassNotFoundException ex) {
            Logger.getLogger(DistanceGenerator_LITE.class.getName()).log(Level.SEVERE, null, ex);
        } 

        
        
        
    }
    
}
